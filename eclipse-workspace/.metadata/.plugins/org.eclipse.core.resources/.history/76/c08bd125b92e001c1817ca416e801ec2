package assignment1;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Scanner;

public class Board {
	public int size = 5;

	// 2D Array of Cells for representation of the game board
	public final Cell[][] board = new Cell[size][size];

	private Piece.Type turn;
	private Piece.Type winner;

	/**
	 * Create a Board with the current player turn set.
	 */
	public Board() {
		this.loadBoard("Boards/Starter.txt");
	}

	/**
	 * Create a Board with the current player turn set and a specified board.
	 * 
	 * @param boardFilePath The path to the board file to import (e.g.
	 *                      "Boards/Starter.txt")
	 */
	public Board(String boardFilePath) {
		this.loadBoard(boardFilePath);
	}

	/**
	 * Creates a Board copy of the given board.
	 * 
	 * @param board Board to copy
	 */
	public Board(Board board) {
		this.size = board.size;
		for (int row = 0; row < size; row++) {
			for (int col = 0; col < size; col++) {
				this.board[row][col] = new Cell(board.board[row][col]);
			}
		}
		this.turn = board.turn;
		this.winner = board.winner;
	}

	/**
	 * @return the Piece.Type (Muskeeteer or Guard) of the current turn
	 */
	public Piece.Type getTurn() {
		return turn;
	}

	/**
	 * Get the cell located on the board at the given coordinate.
	 * 
	 * @param coordinate Coordinate to find the cell
	 * @return Cell that is located at the given coordinate
	 */
	public Cell getCell(Coordinate coordinate) { // TODO
		for (int i = 0; i < board.length; i++) {
			for (int j = 0; j < board[i].length; j++) {
				if (i == coordinate.row && j == coordinate.col) {
					return board[i][j];
				}
			}
		}
		return null;
	}

	/**
	 * @return the game winner Piece.Type (Muskeeteer or Guard) if there is one
	 *         otherwise null
	 */
	public Piece.Type getWinner() {
		return winner;
	}

	/**
	 * Gets all the Musketeer cells on the board.
	 * 
	 * @return List of cells
	 */
	public List<Cell> getMusketeerCells() { // TODO
		List<Cell> musketeerCells = new ArrayList<Cell>();

		for (int i = 0; i < board.length; i++) {
			for (int j = 0; j < board[i].length; j++) {
				Cell cell = getCell(new Coordinate(i, j));
				if (cell.getPiece() instanceof Musketeer) {
					musketeerCells.add(cell);
				}
			}
		}
		return musketeerCells;
	}

	/**
	 * Gets all the Guard cells on the board.
	 * 
	 * @return List of cells
	 */
	public List<Cell> getGuardCells() { // TODO
		List<Cell> guardCells = new ArrayList<Cell>();

		for (int i = 0; i < board.length; i++) {
			for (int j = 0; j < board[i].length; j++) {
				Cell cell = getCell(new Coordinate(i, j));
				if (cell.getPiece() instanceof Guard) {
					guardCells.add(cell);
				}
			}
		}
		return guardCells;
	}

	/**
	 * Executes the given move on the board and changes turns at the end of the
	 * method.
	 * 
	 * @param move a valid move
	 */
	public void move(Move move) { // TODO
		Cell oriCell = getCell(move.fromCell.getCoordinate());
		Cell dirCell = getCell(move.toCell.getCoordinate());
		dirCell.setPiece(oriCell.getPiece());
		oriCell.removePiece();
	}

	/**
	 * Undo the move given.
	 * 
	 * @param move Copy of a move that was done and needs to be undone. The move
	 *             copy has the correct piece info in the from and to cell fields.
	 *             Changes turns at the end of the method.
	 */
	public void undoMove(Move move) { // TODO
		Cell oriCell = getCell(move.fromCell.getCoordinate());
		Cell dirCell = getCell(move.toCell.getCoordinate());
		oriCell.setPiece(oriCell.getPiece());
		dirCell.removePiece();
	}

	/**
	 * Checks if the given move is valid. Things to check: (1) the toCell is next to
	 * the fromCell (2) the fromCell piece can move onto the toCell piece.
	 * 
	 * @param move a move
	 * @return True, if the move is valid, false otherwise
	 */
	public Boolean isValidMove(Move move) { // TODO
		Cell fromCell = getCell(move.fromCell.getCoordinate());
		Cell toCell = getCell(move.toCell.getCoordinate());
		int fromCol = fromCell.getCoordinate().col;
		int fromRow = fromCell.getCoordinate().row;
		int toCol = toCell.getCoordinate().col;
		int toRow = toCell.getCoordinate().row;

		int rowDis = Math.abs(fromRow - toRow);
		int colDis = Math.abs(fromCol - toCol);

		if ((rowDis == 1 && colDis == 0) || (colDis == 1 && rowDis == 0)) {
			if (fromCell.getPiece() instanceof Musketeer && toCell.getPiece() instanceof Guard) {
				return true;
			} else if (fromCell.getPiece() instanceof Guard && toCell.getPiece() == null) {
				return true;
			}
		}
		return false;
	}
	
	/**
	 * Check whether a cell is a valid cell (inside the board)
	 * @param cell a cell
	 * @return True, if the cell is valid, false otherwise
	 */
	
	private Boolean isValidCoordinate(Coordinate coordinate) {
		
		int row = coordinate.row;
		int col = coordinate.col;
		
		if (row < size && row >= 0 && col < size && col >= 0) {
			return true;
		}
		
		return false;
	}

	/**
	 * Get all the possible cells that have pieces that can be moved this turn.
	 * 
	 * @return Cells that can be moved from the given cells
	 */
	public List<Cell> getPossibleCells() { // TODO
		ArrayList<Cell> possibleCells = new ArrayList<Cell>();
		
		
		if (getTurn().equals(Piece.Type.MUSKETEER)) {
			for (Cell cell : getMusketeerCells()) {
				int col = cell.getCoordinate().col;
				int row = cell.getCoordinate().row;
				
				Coordinate[] c = {new Coordinate(row - 1, col), new Coordinate(row + 1, col), new Coordinate(row, col - 1), new Coordinate(row, col + 1)};
				
				for (Coordinate coordinate : c) {
					if (!possibleCells.contains(cell) && isValidCoordinate(coordinate) && getCell(coordinate).getPiece().getType() == Piece.Type.GUARD) {
						possibleCells.add(cell);
					}
				}	
				
			}
			
			
		} else if (getTurn().equals(Piece.Type.GUARD)) {
			for (Cell cell : getGuardCells()) {
				int col = cell.getCoordinate().col;
				int row = cell.getCoordinate().row;
				
				Coordinate[] c = {new Coordinate(row - 1, col), new Coordinate(row + 1, col), new Coordinate(row, col - 1), new Coordinate(row, col + 1)};
				
				for (Coordinate coordinate : c) {
					if (!possibleCells.contains(cell) && isValidCoordinate(coordinate) && !getCell(coordinate).hasPiece()) {
						possibleCells.add(cell);
					}
				}	
				
			}
		}
		
		
		return possibleCells;
	}

	/**
	 * Get all the possible cell destinations that is possible to move to from the
	 * fromCell.
	 * 
	 * @param fromCell The cell that has the piece that is going to be moved
	 * @return List of cells that are possible to get to
	 */
	public List<Cell> getPossibleDestinations(Cell fromCell) { // TODO
		ArrayList<Cell> possibleDestinations = new ArrayList<Cell>();
		
		Cell from = getCell(fromCell.getCoordinate());
		
		if (from.getPiece().getType() == Piece.Type.MUSKETEER) {
			int col = from.getCoordinate().col;
			int row = from.getCoordinate().row;
			
			Coordinate[] c = {new Coordinate(row - 1, col), new Coordinate(row + 1, col), new Coordinate(row, col - 1), new Coordinate(row, col + 1)};
			
			for (Coordinate coordinate: c) {
				Cell cell = getCell(coordinate);
				if (!possibleDestinations.contains(cell) && isValidCoordinate(coordinate) && cell.getPiece().getType() == Piece.Type.GUARD) {
					possibleDestinations.add(cell);
				}
			}
		} else if (from.getPiece().getType() == Piece.Type.GUARD) {
			int col = from.getCoordinate().col;
			int row = from.getCoordinate().row;
			
			Coordinate[] c = {new Coordinate(row - 1, col), new Coordinate(row + 1, col), new Coordinate(row, col - 1), new Coordinate(row, col + 1)};
			
			for (Coordinate coordinate: c) {
				Cell cell = getCell(coordinate);
				if (!possibleDestinations.contains(cell) && isValidCoordinate(coordinate) && !cell.hasPiece()) {
					possibleDestinations.add(cell);
				}
			}
		}
		
		return possibleDestinations;
	}

	/**
	 * Get all the possible moves that can be made this turn.
	 * 
	 * @return List of moves that can be made this turn
	 */
	public List<Move> getPossibleMoves() { // TODO
		return List.of();
	}

	/**
	 * Checks if the game is over and sets the winner if there is one.
	 * 
	 * @return True, if the game is over, false otherwise.
	 */
	public boolean isGameOver() { // TODO
		
		if (getWinner() == null) {
			return false;
		}
		
		
		return true;
	}

	/**
	 * Saves the current board state to the boards directory
	 */
	public void saveBoard() {
		String filePath = String.format("boards/%s.txt",
				new SimpleDateFormat("yyyy.MM.dd.HH.mm.ss").format(new Date()));
		File file = new File(filePath);

		try {
			file.createNewFile();
			Writer writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file)));
			writer.write(turn.getType() + "\n");
			for (Cell[] row : board) {
				StringBuilder line = new StringBuilder();
				for (Cell cell : row) {
					if (cell.getPiece() != null) {
						line.append(cell.getPiece().getSymbol());
					} else {
						line.append("_");
					}
					line.append(" ");
				}
				writer.write(line.toString().strip() + "\n");
			}
			writer.close();
			System.out.printf("Saved board to %s.\n", filePath);
		} catch (IOException e) {
			e.printStackTrace();
			System.out.printf("Failed to save board to %s.\n", filePath);
		}
	}

	@Override
	public String toString() {
		StringBuilder boardStr = new StringBuilder("  | A B C D E\n");
		boardStr.append("--+----------\n");
		for (int i = 0; i < size; i++) {
			boardStr.append(i + 1).append(" | ");
			for (int j = 0; j < size; j++) {
				Cell cell = board[i][j];
				boardStr.append(cell).append(" ");
			}
			boardStr.append("\n");
		}
		return boardStr.toString();
	}

	/**
	 * Loads a board file from a file path.
	 * 
	 * @param filePath The path to the board file to load (e.g.
	 *                 "Boards/Starter.txt")
	 */
	private void loadBoard(String filePath) {
		File file = new File(filePath);
		Scanner scanner = null;
		try {
			scanner = new Scanner(file);
		} catch (FileNotFoundException e) {
			System.err.printf("File at %s not found.", filePath);
			System.exit(1);
		}

		turn = Piece.Type.valueOf(scanner.nextLine().toUpperCase());

		int row = 0, col = 0;
		while (scanner.hasNextLine()) {
			String line = scanner.nextLine();
			String[] pieces = line.trim().split(" ");
			for (String piece : pieces) {
				Cell cell = new Cell(new Coordinate(row, col));
				switch (piece) {
				case "O" -> cell.setPiece(new Guard());
				case "X" -> cell.setPiece(new Musketeer());
				default -> cell.setPiece(null);
				}
				this.board[row][col] = cell;
				col += 1;
			}
			col = 0;
			row += 1;
		}
		scanner.close();
		System.out.printf("Loaded board from %s.\n", filePath);
	}

	public static void main(String[] args) {
		Board board = new Board();
		Cell from = new Cell(new Coordinate(0, 4));
		System.out.println(board.getPossibleDestinations(from));
	}
}
